模糊匹配，即对单词进行划分，再枚举每个部分用什么同音拼写代替，
如果能够匹配成功，则将模糊匹配到的单词推到首位。
辅音+元音+（r/l/n/m/g）
注意辅音双写的特例！
注意不发音的特例! (gh)
semelur->s\e\m\e\l\ur->s\i\m\i\l\ar->similar
余下的推荐列表依然根据前缀匹配显示。


每次查找一个单词的复杂度是O(logN)（用map存储词库）
假设有k个音节，枚举j个音节，有O(C(k,j))种，每种替换假设的分支数假设分别为
a1,a2,...aj,则需要枚举O(a1a2..aj)次。

增加一个按钮，可以随时 开启/关闭 智能匹配功能。

根据github上面共同编辑的音节表，
任意两个字母组合，如果在同一个发音行出现过，互相建立关联。
具体存储方式是开一个map，里面每个字母组合都建立一个list，表示和它有关联的字母组合。
每次代码启动的时候自动解析字母组合表，所以只要更新字母组合表，重启代码就可以看到更新效果。
划分单词的时候每次都向后找到最长的能够在表中找到的字母组合。
会不会一个字母组合是另一个的前缀？有可能，但是这种情况考虑更长的组合是更合理的，
因为这种现象几乎只会出现在元音中，而单词中元音一定是连续的段，应当考虑局部最长的元音组合。
例如 tour，our肯定是连续的一个组合，而不是只将o这个前缀作为一个划分。

优化：
1.用户打错音节的数量越多，这种情况出现的概率越小，所以按照替换数量从小到大的
顺序替换，可以更大概率提高用户获得目标信息的速度。
2.并不是同一个发音的组合都可以互相混淆，例如good中的oo，
虽然和ew、ue发音相同，但是几乎不可能有人输入后者，因此这类枚举往往
是无效的，我们可以根据这种判断将oo和ew、ue分裂成更细化的小组，减小每个组的容量，从而降低算法复杂度。
3.单词最后的l直接不管。
4.优先替换元音部分，最后替换辅音部分。

细节：以单词可以尝试在结尾+e或者-e


答辩的要点：
1.要有数据，实验数据。
2.要有算法，体现出我们的思考。
3.演示部分，有创意，有艺术。
